## AbstractQueuedSynchronizer

**什么是AQS？**

- AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效的构造出应用广泛的大量的同步器，比如ReentrantLock、Semaphore、SynchronousQueue等。

**AQS的核心思想是什么？**

- AQS的核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
- CLH队列：是⼀个虚拟的双向队列（虚拟的双向队列即不存在队列实 例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个 结点（Node）来实现锁的分配。

AQS使⽤⼀个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队⼯作。AQS 使⽤CAS对该同步状态进⾏原⼦操作实现对其值的修改。

AQS 对资源的共享⽅式：

- Exclusive（独占）：只有⼀个线程能执⾏，如ReentrantLock。⼜可分为公平锁和⾮公平锁： 
  - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 
  - ⾮公平锁：当线程要获取锁时，⽆视队列顺序直接去抢锁，谁抢到就是谁的
- Share（共享）：多个线程可同时执⾏，如Semaphore/CountDownLatch。Semaphore、 CountDownLatch、 CyclicBarrier、ReadWriteLock 。

ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线 程同时对某⼀资源进⾏读。 

不同的⾃定义同步器争⽤共享资源的⽅式也不同。⾃定义同步器在实现时只需要实现共享资源 state 的获取与释放⽅式即可，⾄于具体线程等待队列的维护（如获取资源失败⼊队/唤醒出队等），AQS已经在顶层实现好了。

**AQS底层使⽤了模板⽅法模式**

同步器的设计是基于模板⽅法模式的，如果需要⾃定义同步器⼀般的⽅式是这样（模板⽅法模式很经典 的⼀个应⽤）： 

- 使⽤者继承AbstractQueuedSynchronizer并重写指定的⽅法。（这些重写⽅法很简单，⽆⾮是对 于共享资源state的获取和释放）

- 将AQS组合在⾃定义同步组件的实现中，并调⽤其模板⽅法，⽽这些模板⽅法会调⽤使⽤者重写 的⽅法。 这和我们以往通过实现接⼝的⽅式有很⼤区别，这是模板⽅法模式很经典的⼀个运⽤。