## 线程八股文

#### 1.进程和线程的区别？

- 进程是操作系统的最小单位
- 线程是CPU的最小单位

#### 2.Java线程中的创建方法？

- 继承Thread类
- 实现Runnable接口
- 实现Callable接口，可返回线程执行结果

实现接口的方式更实用，因为Java不支持多继承模式，但可以实现多个接口。

#### 3.线程的状态有哪些？

- 新建（New）
- 可运行（Runable）
- 阻塞（Blocking）
- 无限期等待（Waiting）
- 限期等待（Timed Waiting）
- 死亡（Terminated）

#### 4.什么是线程死锁？

死锁是指两个或两个以上线程在执行过程中，因争夺资源而造成的互相等待的现象。

死锁产生的四个必要条件

- 互斥条件：该资源在任意时刻只能由一个线程持有
- 请求持有条件：一个线程因请求资源而阻塞，但对以获取的资源不释放
- 不可剥夺条件：线程获取到的资源在执行完之前不可被其他线程抢占
- 环路等待条件：发生死锁时，必然存在一个线程-资源的环形链

#### 5.如何避免线程死锁？

只需破坏产生死锁的必要条件即可

- 破坏互斥条件：没法破坏，临界资源需要互斥
- 破坏请求持有条件：一次性申请所有资源
- 破坏不可剥夺条件：占用部分资源的线程申请其他资源时，如果申请不到，可以主动释放它占有的资源
- 破坏环路等待条件：按序申请资源，反序释放资源

#### 6.start()方法和run()方法的区别？

- 调用start()方法会启动一个线程并使线程处于可运行状态，当CPU分配到时间片时就可以运行了。 start()方法会执⾏线程的相应准备⼯作，然后⾃动执⾏ run() ⽅法的内容，这是真正的多线程⼯作。
- 直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main 线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。

#### 7.sleep()方法和wait()方法的区别？

- sleep方法没有释放锁，wait方法释放了锁
- Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去
- wait 方法通常被⽤于线程间交互/通信，sleep 方法通常被⽤于暂停执⾏

#### 8.介绍下Java内存模型

Java内存模型定义了Java程序中访问变量的规则。其规定所有变量都存储在主内存中，线程均有自己的工作内存。工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。

#### 9.简述as-if-serial

编译器等会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果和用户原始程序输出预定结果一致。

#### 10.简述可见性

当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile，synchronized,final都能够保证可见性。

#### 11.简述volatile关键字作用

- 保证变量的可见性
- 禁止指令重排序优化

#### 12.并发和并行的区别

- 并发是指同一个时间段，多个任务同时执行（单核CPU使用时间片切换执行任务）
- 并行是指单位时间内，多个任务同时执行（多核CPU同时执行任务）

#### 13.Java并发编程的三个重要特性

- 原子性：一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。
- 可见性：可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。
- 有序性：即虽然多线程存在并发和指令优化等操作，在本线程内观察该线程的所有执行操作是有序的。

